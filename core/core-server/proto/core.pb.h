// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#ifndef PROTOBUF_INCLUDED_core_2eproto
#define PROTOBUF_INCLUDED_core_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_core_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_core_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_core_2eproto();
namespace seismic_core {
class ShatterLinkRequest;
class ShatterLinkRequestDefaultTypeInternal;
extern ShatterLinkRequestDefaultTypeInternal _ShatterLinkRequest_default_instance_;
class ShatterReply;
class ShatterReplyDefaultTypeInternal;
extern ShatterReplyDefaultTypeInternal _ShatterReply_default_instance_;
class SurfaceReply;
class SurfaceReplyDefaultTypeInternal;
extern SurfaceReplyDefaultTypeInternal _SurfaceReply_default_instance_;
class SurfaceRequest;
class SurfaceRequestDefaultTypeInternal;
extern SurfaceRequestDefaultTypeInternal _SurfaceRequest_default_instance_;
class SurfaceValue;
class SurfaceValueDefaultTypeInternal;
extern SurfaceValueDefaultTypeInternal _SurfaceValue_default_instance_;
}  // namespace seismic_core
namespace google {
namespace protobuf {
template<> ::seismic_core::ShatterLinkRequest* Arena::CreateMaybeMessage<::seismic_core::ShatterLinkRequest>(Arena*);
template<> ::seismic_core::ShatterReply* Arena::CreateMaybeMessage<::seismic_core::ShatterReply>(Arena*);
template<> ::seismic_core::SurfaceReply* Arena::CreateMaybeMessage<::seismic_core::SurfaceReply>(Arena*);
template<> ::seismic_core::SurfaceRequest* Arena::CreateMaybeMessage<::seismic_core::SurfaceRequest>(Arena*);
template<> ::seismic_core::SurfaceValue* Arena::CreateMaybeMessage<::seismic_core::SurfaceValue>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace seismic_core {

// ===================================================================

class SurfaceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:seismic_core.SurfaceRequest) */ {
 public:
  SurfaceRequest();
  virtual ~SurfaceRequest();

  SurfaceRequest(const SurfaceRequest& from);

  inline SurfaceRequest& operator=(const SurfaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceRequest(SurfaceRequest&& from) noexcept
    : SurfaceRequest() {
    *this = ::std::move(from);
  }

  inline SurfaceRequest& operator=(SurfaceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SurfaceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceRequest* internal_default_instance() {
    return reinterpret_cast<const SurfaceRequest*>(
               &_SurfaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SurfaceRequest* other);
  friend void swap(SurfaceRequest& a, SurfaceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceRequest* New() const final {
    return CreateMaybeMessage<SurfaceRequest>(nullptr);
  }

  SurfaceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceRequest& from);
  void MergeFrom(const SurfaceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string surface = 1;
  void clear_surface();
  static const int kSurfaceFieldNumber = 1;
  const ::std::string& surface() const;
  void set_surface(const ::std::string& value);
  #if LANG_CXX11
  void set_surface(::std::string&& value);
  #endif
  void set_surface(const char* value);
  void set_surface(const char* value, size_t size);
  ::std::string* mutable_surface();
  ::std::string* release_surface();
  void set_allocated_surface(::std::string* surface);

  // string basename = 2;
  void clear_basename();
  static const int kBasenameFieldNumber = 2;
  const ::std::string& basename() const;
  void set_basename(const ::std::string& value);
  #if LANG_CXX11
  void set_basename(::std::string&& value);
  #endif
  void set_basename(const char* value);
  void set_basename(const char* value, size_t size);
  ::std::string* mutable_basename();
  ::std::string* release_basename();
  void set_allocated_basename(::std::string* basename);

  // int32 cubexs = 3;
  void clear_cubexs();
  static const int kCubexsFieldNumber = 3;
  ::google::protobuf::int32 cubexs() const;
  void set_cubexs(::google::protobuf::int32 value);

  // int32 cubeys = 4;
  void clear_cubeys();
  static const int kCubeysFieldNumber = 4;
  ::google::protobuf::int32 cubeys() const;
  void set_cubeys(::google::protobuf::int32 value);

  // int32 cubezs = 5;
  void clear_cubezs();
  static const int kCubezsFieldNumber = 5;
  ::google::protobuf::int32 cubezs() const;
  void set_cubezs(::google::protobuf::int32 value);

  // int32 fragmentxs = 6;
  void clear_fragmentxs();
  static const int kFragmentxsFieldNumber = 6;
  ::google::protobuf::int32 fragmentxs() const;
  void set_fragmentxs(::google::protobuf::int32 value);

  // int32 fragmentys = 7;
  void clear_fragmentys();
  static const int kFragmentysFieldNumber = 7;
  ::google::protobuf::int32 fragmentys() const;
  void set_fragmentys(::google::protobuf::int32 value);

  // int32 fragmentzs = 8;
  void clear_fragmentzs();
  static const int kFragmentzsFieldNumber = 8;
  ::google::protobuf::int32 fragmentzs() const;
  void set_fragmentzs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:seismic_core.SurfaceRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr surface_;
  ::google::protobuf::internal::ArenaStringPtr basename_;
  ::google::protobuf::int32 cubexs_;
  ::google::protobuf::int32 cubeys_;
  ::google::protobuf::int32 cubezs_;
  ::google::protobuf::int32 fragmentxs_;
  ::google::protobuf::int32 fragmentys_;
  ::google::protobuf::int32 fragmentzs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SurfaceValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:seismic_core.SurfaceValue) */ {
 public:
  SurfaceValue();
  virtual ~SurfaceValue();

  SurfaceValue(const SurfaceValue& from);

  inline SurfaceValue& operator=(const SurfaceValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceValue(SurfaceValue&& from) noexcept
    : SurfaceValue() {
    *this = ::std::move(from);
  }

  inline SurfaceValue& operator=(SurfaceValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SurfaceValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceValue* internal_default_instance() {
    return reinterpret_cast<const SurfaceValue*>(
               &_SurfaceValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SurfaceValue* other);
  friend void swap(SurfaceValue& a, SurfaceValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceValue* New() const final {
    return CreateMaybeMessage<SurfaceValue>(nullptr);
  }

  SurfaceValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceValue& from);
  void MergeFrom(const SurfaceValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 i = 1;
  void clear_i();
  static const int kIFieldNumber = 1;
  ::google::protobuf::int64 i() const;
  void set_i(::google::protobuf::int64 value);

  // double v = 2;
  void clear_v();
  static const int kVFieldNumber = 2;
  double v() const;
  void set_v(double value);

  // @@protoc_insertion_point(class_scope:seismic_core.SurfaceValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 i_;
  double v_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SurfaceReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:seismic_core.SurfaceReply) */ {
 public:
  SurfaceReply();
  virtual ~SurfaceReply();

  SurfaceReply(const SurfaceReply& from);

  inline SurfaceReply& operator=(const SurfaceReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceReply(SurfaceReply&& from) noexcept
    : SurfaceReply() {
    *this = ::std::move(from);
  }

  inline SurfaceReply& operator=(SurfaceReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SurfaceReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceReply* internal_default_instance() {
    return reinterpret_cast<const SurfaceReply*>(
               &_SurfaceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SurfaceReply* other);
  friend void swap(SurfaceReply& a, SurfaceReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceReply* New() const final {
    return CreateMaybeMessage<SurfaceReply>(nullptr);
  }

  SurfaceReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceReply& from);
  void MergeFrom(const SurfaceReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .seismic_core.SurfaceValue surface = 1;
  int surface_size() const;
  void clear_surface();
  static const int kSurfaceFieldNumber = 1;
  ::seismic_core::SurfaceValue* mutable_surface(int index);
  ::google::protobuf::RepeatedPtrField< ::seismic_core::SurfaceValue >*
      mutable_surface();
  const ::seismic_core::SurfaceValue& surface(int index) const;
  ::seismic_core::SurfaceValue* add_surface();
  const ::google::protobuf::RepeatedPtrField< ::seismic_core::SurfaceValue >&
      surface() const;

  // @@protoc_insertion_point(class_scope:seismic_core.SurfaceReply)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::seismic_core::SurfaceValue > surface_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class ShatterLinkRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:seismic_core.ShatterLinkRequest) */ {
 public:
  ShatterLinkRequest();
  virtual ~ShatterLinkRequest();

  ShatterLinkRequest(const ShatterLinkRequest& from);

  inline ShatterLinkRequest& operator=(const ShatterLinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShatterLinkRequest(ShatterLinkRequest&& from) noexcept
    : ShatterLinkRequest() {
    *this = ::std::move(from);
  }

  inline ShatterLinkRequest& operator=(ShatterLinkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ShatterLinkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShatterLinkRequest* internal_default_instance() {
    return reinterpret_cast<const ShatterLinkRequest*>(
               &_ShatterLinkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ShatterLinkRequest* other);
  friend void swap(ShatterLinkRequest& a, ShatterLinkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShatterLinkRequest* New() const final {
    return CreateMaybeMessage<ShatterLinkRequest>(nullptr);
  }

  ShatterLinkRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShatterLinkRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShatterLinkRequest& from);
  void MergeFrom(const ShatterLinkRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShatterLinkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string link = 1;
  void clear_link();
  static const int kLinkFieldNumber = 1;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  #if LANG_CXX11
  void set_link(::std::string&& value);
  #endif
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // @@protoc_insertion_point(class_scope:seismic_core.ShatterLinkRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class ShatterReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:seismic_core.ShatterReply) */ {
 public:
  ShatterReply();
  virtual ~ShatterReply();

  ShatterReply(const ShatterReply& from);

  inline ShatterReply& operator=(const ShatterReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShatterReply(ShatterReply&& from) noexcept
    : ShatterReply() {
    *this = ::std::move(from);
  }

  inline ShatterReply& operator=(ShatterReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ShatterReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShatterReply* internal_default_instance() {
    return reinterpret_cast<const ShatterReply*>(
               &_ShatterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ShatterReply* other);
  friend void swap(ShatterReply& a, ShatterReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShatterReply* New() const final {
    return CreateMaybeMessage<ShatterReply>(nullptr);
  }

  ShatterReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShatterReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShatterReply& from);
  void MergeFrom(const ShatterReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShatterReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string link = 1;
  void clear_link();
  static const int kLinkFieldNumber = 1;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  #if LANG_CXX11
  void set_link(::std::string&& value);
  #endif
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // @@protoc_insertion_point(class_scope:seismic_core.ShatterReply)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SurfaceRequest

// string surface = 1;
inline void SurfaceRequest::clear_surface() {
  surface_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SurfaceRequest::surface() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.surface)
  return surface_.GetNoArena();
}
inline void SurfaceRequest::set_surface(const ::std::string& value) {
  
  surface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.surface)
}
#if LANG_CXX11
inline void SurfaceRequest::set_surface(::std::string&& value) {
  
  surface_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:seismic_core.SurfaceRequest.surface)
}
#endif
inline void SurfaceRequest::set_surface(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  surface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:seismic_core.SurfaceRequest.surface)
}
inline void SurfaceRequest::set_surface(const char* value, size_t size) {
  
  surface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:seismic_core.SurfaceRequest.surface)
}
inline ::std::string* SurfaceRequest::mutable_surface() {
  
  // @@protoc_insertion_point(field_mutable:seismic_core.SurfaceRequest.surface)
  return surface_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SurfaceRequest::release_surface() {
  // @@protoc_insertion_point(field_release:seismic_core.SurfaceRequest.surface)
  
  return surface_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SurfaceRequest::set_allocated_surface(::std::string* surface) {
  if (surface != nullptr) {
    
  } else {
    
  }
  surface_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), surface);
  // @@protoc_insertion_point(field_set_allocated:seismic_core.SurfaceRequest.surface)
}

// string basename = 2;
inline void SurfaceRequest::clear_basename() {
  basename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SurfaceRequest::basename() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.basename)
  return basename_.GetNoArena();
}
inline void SurfaceRequest::set_basename(const ::std::string& value) {
  
  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.basename)
}
#if LANG_CXX11
inline void SurfaceRequest::set_basename(::std::string&& value) {
  
  basename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:seismic_core.SurfaceRequest.basename)
}
#endif
inline void SurfaceRequest::set_basename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:seismic_core.SurfaceRequest.basename)
}
inline void SurfaceRequest::set_basename(const char* value, size_t size) {
  
  basename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:seismic_core.SurfaceRequest.basename)
}
inline ::std::string* SurfaceRequest::mutable_basename() {
  
  // @@protoc_insertion_point(field_mutable:seismic_core.SurfaceRequest.basename)
  return basename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SurfaceRequest::release_basename() {
  // @@protoc_insertion_point(field_release:seismic_core.SurfaceRequest.basename)
  
  return basename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SurfaceRequest::set_allocated_basename(::std::string* basename) {
  if (basename != nullptr) {
    
  } else {
    
  }
  basename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), basename);
  // @@protoc_insertion_point(field_set_allocated:seismic_core.SurfaceRequest.basename)
}

// int32 cubexs = 3;
inline void SurfaceRequest::clear_cubexs() {
  cubexs_ = 0;
}
inline ::google::protobuf::int32 SurfaceRequest::cubexs() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.cubexs)
  return cubexs_;
}
inline void SurfaceRequest::set_cubexs(::google::protobuf::int32 value) {
  
  cubexs_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.cubexs)
}

// int32 cubeys = 4;
inline void SurfaceRequest::clear_cubeys() {
  cubeys_ = 0;
}
inline ::google::protobuf::int32 SurfaceRequest::cubeys() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.cubeys)
  return cubeys_;
}
inline void SurfaceRequest::set_cubeys(::google::protobuf::int32 value) {
  
  cubeys_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.cubeys)
}

// int32 cubezs = 5;
inline void SurfaceRequest::clear_cubezs() {
  cubezs_ = 0;
}
inline ::google::protobuf::int32 SurfaceRequest::cubezs() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.cubezs)
  return cubezs_;
}
inline void SurfaceRequest::set_cubezs(::google::protobuf::int32 value) {
  
  cubezs_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.cubezs)
}

// int32 fragmentxs = 6;
inline void SurfaceRequest::clear_fragmentxs() {
  fragmentxs_ = 0;
}
inline ::google::protobuf::int32 SurfaceRequest::fragmentxs() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.fragmentxs)
  return fragmentxs_;
}
inline void SurfaceRequest::set_fragmentxs(::google::protobuf::int32 value) {
  
  fragmentxs_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.fragmentxs)
}

// int32 fragmentys = 7;
inline void SurfaceRequest::clear_fragmentys() {
  fragmentys_ = 0;
}
inline ::google::protobuf::int32 SurfaceRequest::fragmentys() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.fragmentys)
  return fragmentys_;
}
inline void SurfaceRequest::set_fragmentys(::google::protobuf::int32 value) {
  
  fragmentys_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.fragmentys)
}

// int32 fragmentzs = 8;
inline void SurfaceRequest::clear_fragmentzs() {
  fragmentzs_ = 0;
}
inline ::google::protobuf::int32 SurfaceRequest::fragmentzs() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceRequest.fragmentzs)
  return fragmentzs_;
}
inline void SurfaceRequest::set_fragmentzs(::google::protobuf::int32 value) {
  
  fragmentzs_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceRequest.fragmentzs)
}

// -------------------------------------------------------------------

// SurfaceValue

// int64 i = 1;
inline void SurfaceValue::clear_i() {
  i_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 SurfaceValue::i() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceValue.i)
  return i_;
}
inline void SurfaceValue::set_i(::google::protobuf::int64 value) {
  
  i_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceValue.i)
}

// double v = 2;
inline void SurfaceValue::clear_v() {
  v_ = 0;
}
inline double SurfaceValue::v() const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceValue.v)
  return v_;
}
inline void SurfaceValue::set_v(double value) {
  
  v_ = value;
  // @@protoc_insertion_point(field_set:seismic_core.SurfaceValue.v)
}

// -------------------------------------------------------------------

// SurfaceReply

// repeated .seismic_core.SurfaceValue surface = 1;
inline int SurfaceReply::surface_size() const {
  return surface_.size();
}
inline void SurfaceReply::clear_surface() {
  surface_.Clear();
}
inline ::seismic_core::SurfaceValue* SurfaceReply::mutable_surface(int index) {
  // @@protoc_insertion_point(field_mutable:seismic_core.SurfaceReply.surface)
  return surface_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::seismic_core::SurfaceValue >*
SurfaceReply::mutable_surface() {
  // @@protoc_insertion_point(field_mutable_list:seismic_core.SurfaceReply.surface)
  return &surface_;
}
inline const ::seismic_core::SurfaceValue& SurfaceReply::surface(int index) const {
  // @@protoc_insertion_point(field_get:seismic_core.SurfaceReply.surface)
  return surface_.Get(index);
}
inline ::seismic_core::SurfaceValue* SurfaceReply::add_surface() {
  // @@protoc_insertion_point(field_add:seismic_core.SurfaceReply.surface)
  return surface_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::seismic_core::SurfaceValue >&
SurfaceReply::surface() const {
  // @@protoc_insertion_point(field_list:seismic_core.SurfaceReply.surface)
  return surface_;
}

// -------------------------------------------------------------------

// ShatterLinkRequest

// string link = 1;
inline void ShatterLinkRequest::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ShatterLinkRequest::link() const {
  // @@protoc_insertion_point(field_get:seismic_core.ShatterLinkRequest.link)
  return link_.GetNoArena();
}
inline void ShatterLinkRequest::set_link(const ::std::string& value) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:seismic_core.ShatterLinkRequest.link)
}
#if LANG_CXX11
inline void ShatterLinkRequest::set_link(::std::string&& value) {
  
  link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:seismic_core.ShatterLinkRequest.link)
}
#endif
inline void ShatterLinkRequest::set_link(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:seismic_core.ShatterLinkRequest.link)
}
inline void ShatterLinkRequest::set_link(const char* value, size_t size) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:seismic_core.ShatterLinkRequest.link)
}
inline ::std::string* ShatterLinkRequest::mutable_link() {
  
  // @@protoc_insertion_point(field_mutable:seismic_core.ShatterLinkRequest.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShatterLinkRequest::release_link() {
  // @@protoc_insertion_point(field_release:seismic_core.ShatterLinkRequest.link)
  
  return link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShatterLinkRequest::set_allocated_link(::std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:seismic_core.ShatterLinkRequest.link)
}

// -------------------------------------------------------------------

// ShatterReply

// string link = 1;
inline void ShatterReply::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ShatterReply::link() const {
  // @@protoc_insertion_point(field_get:seismic_core.ShatterReply.link)
  return link_.GetNoArena();
}
inline void ShatterReply::set_link(const ::std::string& value) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:seismic_core.ShatterReply.link)
}
#if LANG_CXX11
inline void ShatterReply::set_link(::std::string&& value) {
  
  link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:seismic_core.ShatterReply.link)
}
#endif
inline void ShatterReply::set_link(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:seismic_core.ShatterReply.link)
}
inline void ShatterReply::set_link(const char* value, size_t size) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:seismic_core.ShatterReply.link)
}
inline ::std::string* ShatterReply::mutable_link() {
  
  // @@protoc_insertion_point(field_mutable:seismic_core.ShatterReply.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShatterReply::release_link() {
  // @@protoc_insertion_point(field_release:seismic_core.ShatterReply.link)
  
  return link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShatterReply::set_allocated_link(::std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:seismic_core.ShatterReply.link)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace seismic_core

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_core_2eproto
