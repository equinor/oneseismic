trigger:
  - master
  - release

pool:
  vmImage: 'ubuntu-18.04'

variables:
  GOPATH: '$(system.defaultWorkingDirectory)/gopath'
  GOVERSION: '1.13.4'
  TEST_COVERAGE_LIMIT: 38

jobs:
  - job: Build_Core
    steps:
      - script: |
          wget https://github.com/fmtlib/fmt/releases/download/6.0.0/fmt-6.0.0.zip
          unzip fmt-6.0.0.zip
          mkdir -p fmt-6.0.0/build
          cd fmt-6.0.0/build
          cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTING=OFF -DBUILD_SHARED_LIBS=ON
          sudo make install -j2
        displayName: 'Build fmt'
      - script: |
          sudo apt-get update
          sudo apt-get install -y libgnutls28-dev libcurl4-gnutls-dev
          sudo apt-get install -y protobuf-compiler-grpc libprotobuf-dev libgrpc++-dev
          sudo pip install scikit-build pybind11
          mkdir build
          cd build
          cmake ../core -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON
        displayName: 'Setup seismic-cloud'

      - script: |
          make
        displayName: 'Build seismic-cloud Core'
        workingDirectory: build

      - script: |
          ctest --output-on-failure
        displayName: 'Test seismic-cloud Core'
        workingDirectory: build

  - job: Test_Ingestion
    steps:
      - script: |
          docker-compose up --build --exit-code-from int_tests
        displayName: 'Test Ingestion'
        workingDirectory: core/ingestion

  - job: Build_API
    variables:
      GOPATH: '$(system.defaultWorkingDirectory)/gopath'
      TEST_COVERAGE_LIMIT: 35
    steps:
      - bash: |
          echo "##vso[task.prependpath]$(GOPATH)/bin"
        displayName: Update PATH

      - task: GoTool@0
        inputs:
          version: '$(GOVERSION)'
          goPath: '$(GOPATH)'
          goBin: '$(GOPATH)/bin'
      - script: |
          sudo apt-get install -y protobuf-compiler
        displayName: 'Fetching debian dependencies'
        workingDirectory: api
      - script: |
          go generate ./...
        workingDirectory: api
        displayName: 'Generate OpenAPI spec'

      - script: |
          go build
        workingDirectory: api
        displayName: 'Build api'

  - job: Run_unit_tests
    steps:
      - bash: |
          echo "##vso[task.prependpath]$(GOPATH)/bin"
        displayName: Update PATH

      - task: GoTool@0
        inputs:
          version: '$(GOVERSION)'
          goPath: '$(GOPATH)'
          goBin: '$(GOPATH)/bin'

      - script: |
          go test -race ./...
        workingDirectory: api
        displayName: 'Run unit tests'

  - job: Test_coverage
    steps:
      - bash: |
          echo "##vso[task.prependpath]$(GOPATH)/bin"
        displayName: Update PATH

      - task: GoTool@0
        inputs:
          version: '$(GOVERSION)'
          goPath: '$(GOPATH)'
          goBin: '$(GOPATH)/bin'

      - script: |
          go get github.com/jstemmer/go-junit-report
          go get github.com/axw/gocov/gocov
          go get github.com/AlekSi/gocov-xml
          go get github.com/matm/gocov-html
          go test -v -coverprofile=coverage.txt -covermode count 2>&1 ./... | go-junit-report > report.xml
          gocov convert coverage.txt > coverage.json
          gocov-xml < coverage.json > coverage.xml
          mkdir -p coverage
          gocov-html < coverage.json > coverage/index.html
        displayName: 'Generate test coverage report'
        workingDirectory: api

      - task: PublishCodeCoverageResults@1
        condition: always()
        inputs:
          codeCoverageTool: Cobertura
          summaryFileLocation: $(System.DefaultWorkingDirectory)/**/coverage.xml
          reportDirectory: $(System.DefaultWorkingDirectory)/**/coverage

      - script: |
          COVERAGE=`go tool cover -func coverage.txt | tail -n 1 | awk '{print substr($3, 1, length($3)-1)}'`
          COVERAGE=${COVERAGE%.*}
          echo "Test coverage limit:" $TEST_COVERAGE_LIMIT%
          echo "Test coverage:" $COVERAGE%

          if (( COVERAGE < TEST_COVERAGE_LIMIT )); then
              exit 1
          fi
        displayName: 'Coverage limit'
        workingDirectory: api

  - job: Integration_tests
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    steps:
      - script: |
          sudo curl -L "https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        displayName: Upgrade docker compose
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
      - script: |
          docker-compose build
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
        displayName: 'Build docker images'
      - script: |
          docker-compose -f tests/docker-compose.yml up --build --exit-code-from test
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
        displayName: 'Run integration tests'
      - script: |
          echo $(ACRPASSWD)|docker login -u lambdaville lambdaville.azurecr.io --password-stdin
          docker-compose push
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
        displayName: 'Push docker images'

schedules:
  - cron: '0 6 * * *'
    displayName: nightly build
    branches:
      include:
        - master
    always: true
