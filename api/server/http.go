package server

import (
	"fmt"
	"net/url"
	"regexp"

	"github.com/equinor/seismic-cloud/api/controller"

	jwt "github.com/dgrijalva/jwt-go"
	_ "github.com/equinor/seismic-cloud/api/docs" // docs is generated by Swag CLI, you have to import it.
	claimsmiddleware "github.com/equinor/seismic-cloud/api/middleware/claims"
	profilingmiddleware "github.com/equinor/seismic-cloud/api/middleware/profiling"
	"github.com/equinor/seismic-cloud/api/service"
	"github.com/equinor/seismic-cloud/api/service/store"
	jwtmiddleware "github.com/iris-contrib/middleware/jwt"
	"github.com/iris-contrib/swagger"
	"github.com/iris-contrib/swagger/swaggerFiles"
	"github.com/kataras/iris"
)

type serverMode int

func (sm serverMode) String() string {
	switch sm {
	case NONE:
		return "None"
	case INSECURE:
		return "Insecure"
	case SECURE:
		return "Lets Encrypt"
	case LETSENCRYPT:
		return "Secure"
	default:
		return "Unknown"
	}

}

const (
	NONE serverMode = iota
	INSECURE
	SECURE
	LETSENCRYPT
)

type HttpServer struct {
	service     ApiService
	stitchCmd   []string
	app         *iris.Application
	hostAddr    string
	chosenMode  serverMode
	domains     string
	domainmail  string
	privKeyFile string
	certFile    string
	profile     bool
	addSwagger  bool
}

type ApiService struct {
	manifestStore store.ManifestStore
	profileStore  store.ProfileStore
	surfaceStore  store.SurfaceStore
	stitcher      service.Stitcher
}

type HttpServerOption interface {
	apply(*HttpServer) error
}

func DefaultHttpServer() *HttpServer {

	app := iris.Default()
	app.Logger().SetPrefix("iris: ")
	service.WrapIrisLogger(app.Logger().SetOutput)
	return &HttpServer{
		app:      app,
		hostAddr: "localhost:8080"}
}

func NewHttpServer(opts ...HttpServerOption) (hs *HttpServer, err error) {
	hs = DefaultHttpServer()
	for _, opt := range opts {
		err = opt.apply(hs)
		if err != nil {
			return nil, fmt.Errorf("Applying config failed: %v", err)
		}
	}
	hs.app.Use(iris.Gzip)

	if hs.service.manifestStore == nil {
		return nil, fmt.Errorf("Server cannot start, no manifest store set")
	}

	if hs.service.stitcher == nil {
		return nil, fmt.Errorf("Server cannot start, stitch command is empty")
	}

	if hs.service.surfaceStore == nil {
		return nil, fmt.Errorf("Server cannot start, no surface store set")
	}

	return hs, nil
}

func WithOAuth2(authServer *url.URL, audience, issuer string) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) error {
		sigKeySet, err := service.GetKeySet(authServer)
		if err != nil {
			return fmt.Errorf("Couldn't get keyset: %v", err)
		}

		jwtHandler := jwtmiddleware.New(jwtmiddleware.Config{
			ValidationKeyGetter: func(t *jwt.Token) (interface{}, error) {
				if t.Method.Alg() != "RS256" {
					return nil, fmt.Errorf("unexpected jwt signing method=%v", t.Header["alg"])
				}
				return sigKeySet[t.Header["kid"].(string)], nil
			},

			SigningMethod: jwt.SigningMethodRS256,
		})

		if len(issuer) == 0 {
			issuer = authServer.String()
		}

		claimsHandler := claimsmiddleware.New(audience, issuer)

		hs.app.Use(jwtHandler.Serve)
		hs.app.Use(claimsHandler.Validate)
		return nil
	})
}

func (hs *HttpServer) registerMacros() {
	manifestIDExpr := "^[a-zA-z0-9\\-]{1,40}$"
	manifestIDRegex, err := regexp.Compile(manifestIDExpr)
	if err != nil {
		panic(err)
	}

	hs.app.Macros().Get("string").RegisterFunc("idString", manifestIDRegex.MatchString)
}

func (hs *HttpServer) registerEndpoints() {

	sc := controller.NewSurfaceController(hs.service.surfaceStore)

	hs.app.Post("/surface/{surfaceID:string idString() else 502}", sc.Upload)
	hs.app.Get("/surface/{surfaceID:string idString() else 502}", sc.Download)
	hs.app.Get("/surface", sc.List)
	hs.app.Get("/", func(ctx iris.Context) {
		ctx.HTML("Hello World")
	})

	hs.app.Post("/stitch/{manifestID:string idString() else 502}",
		controller.StitchController(
			hs.service.manifestStore,
			hs.service.stitcher))

	hs.app.Get("/stitchsurface/{manifestID:string idString() else 502}/{surfaceID: string idString() else 502}",
		controller.StitchControllerWithSurfaceID(
			hs.service.manifestStore,
			hs.service.surfaceStore,
			hs.service.stitcher))

}

func (hs *HttpServer) Serve() error {
	hs.registerMacros()
	hs.registerEndpoints()

	if hs.addSwagger {
		config := &swagger.Config{
			URL: hs.hostAddr + "/swagger/doc.json", //The url pointing to API definition
		}
		// use swagger middleware to
		hs.app.Get("/swagger/{any:path}", swagger.CustomWrapHandler(config, swaggerFiles.Handler))
	}

	switch hs.chosenMode {
	case INSECURE:
		return hs.app.Run(iris.Addr(hs.hostAddr))
	case LETSENCRYPT:
		return hs.app.Run(iris.AutoTLS(hs.hostAddr, hs.domains, hs.domainmail))
	case SECURE:
		return hs.app.Run(iris.TLS(hs.hostAddr, hs.certFile, hs.privKeyFile))
	default:
		return fmt.Errorf("no http server mode chosen")
	}
}

func WithManifestStore(manifestStore store.ManifestStore) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {
		hs.service.manifestStore = manifestStore
		return
	})
}

func WithSurfaceStore(surfaceStore store.SurfaceStore) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {
		hs.service.surfaceStore = surfaceStore
		return
	})
}

func WithHostAddr(hostAddr string) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {
		hs.hostAddr = hostAddr
		return
	})
}

func WithHttpOnly() HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {
		hs.chosenMode = INSECURE
		return
	})
}

func WithTLS(certFile, keyFile string) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {

		if len(certFile) == 0 {
			return fmt.Errorf("No cert file selected for TLS")
		}

		if len(keyFile) == 0 {
			return fmt.Errorf("No key file selected for TLS")
		}
		hs.chosenMode = SECURE
		hs.certFile = certFile
		hs.privKeyFile = keyFile
		return
	})
}
func WithLetsEncrypt(domains, domainmail string) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {
		if len(domains) == 0 {
			return fmt.Errorf("No domains selected for LetsEncrypt")
		}

		if len(domainmail) == 0 {
			return fmt.Errorf("No domain mail selected for LetsEncrypt")
		}
		hs.chosenMode = LETSENCRYPT
		hs.domains = domains
		hs.domainmail = domainmail
		return
	})
}

func WithProfiling() HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {
		hs.profile = true
		hs.service.profileStore = &store.ProfileInMemoryStore{}
		hs.app.Use(profilingmiddleware.Init(hs.service.profileStore))
		hs.app.Get("/profile/{profileID:string manifestID() else 502}",
			controller.ProfileController(hs.service.profileStore))
		return
	})
}

func WithSwagger() HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {

		hs.addSwagger = true
		return
	})
}

func WithStitcher(stitcher service.Stitcher) HttpServerOption {

	return newFuncOption(func(hs *HttpServer) (err error) {

		hs.service.stitcher = stitcher
		return
	})
}
